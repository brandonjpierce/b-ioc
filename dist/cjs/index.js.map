{"version":3,"sources":["index.mjs"],"sourcesContent":["/**\n * IoC Module\n * @module b-ioc-js\n */\n\nlet bindings = {};\nlet resolvedBindings = {};\nlet singletons = {};\nlet resolvedSingletons = {};\n\nfunction isString(obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n}\n\nfunction isObject(obj) {\n  const type = typeof obj;\n  return type === 'function' || (type === 'object' && !!obj);\n}\n\nfunction isFunction(obj) {\n  return typeof obj === 'function' || false;\n}\n\nfunction inObject(key, obj) {\n  // biome-ignore lint/suspicious/noPrototypeBuiltins: <explanation>\n  return obj.hasOwnProperty(key);\n}\n\n/**\n * Gets all of the current bindings in the container\n * @method getBindings\n * @return {Object} The containers bindings\n */\nexports.getBindings = function getBindings() {\n  return bindings;\n};\n\n/**\n * Gets all of the current singletons in the container\n * @method getSingletons\n * @return {Object} The containers singletons\n */\nexports.getSingletons = function getSingletons() {\n  return singletons;\n};\n\n/**\n * Resets container to default state\n * @method clear\n */\nexports.clear = function clear() {\n  bindings = {};\n  resolvedBindings = {};\n  singletons = {};\n  resolvedSingletons = {};\n};\n\n/**\n * Assigns to our bindings object\n * @method bind\n * @param  {String} binding The name of the IoC binding\n * @param  {any} closure Factory method or value to bind to container\n */\nexports.bind = function bind(binding, closure) {\n  if (inObject(binding, bindings) || inObject(binding, singletons)) {\n    throw new Error(`Binding: ${binding} already binded.`);\n  }\n\n  if (!isFunction(closure)) {\n    throw new Error(`Binding: ${binding} does not implement a factory.`);\n  }\n\n  bindings[binding] = closure;\n};\n\n/**\n * Assigns to our singleton object\n * @method singleton\n * @param  {String} binding The name of the IoC binding\n * @param  {any} closure Factory method or value to bind to container\n */\nexports.singleton = function singleton(binding, closure) {\n  if (inObject(binding, singletons) || inObject(binding, bindings)) {\n    throw new Error(`Singleton: ${binding} already binded.`);\n  }\n\n  singletons[binding] = closure;\n};\n\n/**\n * Grabs a binding from the IoC. Leverages node require as a fallback\n * @template A\n * @method use<A>\n * @param  {String} binding The name of the binding in the container\n * @returns {A} The instance of the binding\n */\nexports.use = function use(binding) {\n  // biome-ignore lint/style/noArguments: <explanation>\n  const args = Array.prototype.slice.call(arguments, 1);\n\n  // first check bindings\n  if (inObject(binding, bindings)) {\n    if (resolvedBindings[binding]) {\n      throw new Error(`Cyclic dependency detected in binding: ${binding}.`);\n    }\n\n    resolvedBindings[binding] = true;\n\n    const instance = bindings[binding].apply(null, args);\n\n    resolvedBindings[binding] = false;\n\n    return instance;\n  }\n\n  // then check singletons\n  if (inObject(binding, singletons)) {\n    if (!inObject(binding, resolvedSingletons)) {\n      // we are not guarenteed to receive a factory function for a singleton\n      if (isFunction(singletons[binding])) {\n        resolvedSingletons[binding] = singletons[binding].apply(null, args);\n      } else {\n        resolvedSingletons[binding] = singletons[binding];\n      }\n    }\n\n    return resolvedSingletons[binding];\n  }\n\n  // finally check node_modules\n  throw new Error(`Binding: ${binding} not found.`);\n};\n\n/**\n * Creates an instance of a class and will inject dependencies defined in static\n * inject method. This is an alternative to using Ioc.bind\n * @method make\n * @param  {function} Obj The class you wish to create a new instance of\n * @return {Object} The instantiated function instance\n */\nexports.make = function make(Obj) {\n  if (!isFunction(Obj)) {\n    throw new Error(`.make implementation error, expected function got: ${typeof obj}`);\n  }\n\n  if (!Obj.inject) {\n    throw new Error(`.make requires ${obj.constructor.name} to have a static inject method.`);\n  }\n\n  const dependencies = Obj.inject();\n\n  if (dependencies.length) {\n    const resolved = [];\n\n    dependencies.forEach((dependency) => {\n      if (!isString(dependency) && !isObject(dependency)) {\n        throw new Error('static .inject implementation error, a string or object is required.');\n      }\n\n      // string based binding\n      if (isString(dependency)) {\n        resolved.push(exports.use(dependency));\n      }\n\n      // binding you want to pass args to\n      if (isObject(dependency)) {\n        dependency.args.unshift(dependency.key);\n        resolved.push(exports.use.apply(null, dependency.args));\n      }\n    });\n\n    return new (Function.prototype.bind.apply(Obj, [null].concat(resolved)))();\n  }\n  return new Obj();\n};\n"],"names":["bindings","resolvedBindings","singletons","resolvedSingletons","isString","obj","Object","prototype","toString","call","isObject","type","isFunction","inObject","key","hasOwnProperty","exports","getBindings","getSingletons","clear","bind","binding","closure","Error","singleton","use","args","Array","slice","arguments","instance","apply","make","Obj","inject","constructor","name","dependencies","length","resolved","forEach","dependency","push","unshift","Function","concat"],"mappings":"AAAA;;;CAGC;;;;;AAED,IAAIA,WAAW,CAAC;AAChB,IAAIC,mBAAmB,CAAC;AACxB,IAAIC,aAAa,CAAC;AAClB,IAAIC,qBAAqB,CAAC;AAE1B,SAASC,SAASC,IAAG;IACnB,OAAOC,OAAOC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,UAAS;AACjD;AAEA,SAASK,SAASL,IAAG;IACnB,IAAMM,OAAO,OAAON,qCAAP,SAAOA;IACpB,OAAOM,SAAS,cAAeA,SAAS,YAAY,CAAC,CAACN;AACxD;AAEA,SAASO,WAAWP,IAAG;IACrB,OAAO,OAAOA,SAAQ,cAAc;AACtC;AAEA,SAASQ,SAASC,GAAG,EAAET,IAAG;IACxB,kEAAkE;IAClE,OAAOA,KAAIU,cAAc,CAACD;AAC5B;AAEA;;;;CAIC,GACDE,QAAQC,WAAW,GAAG,SAASA;IAC7B,OAAOjB;AACT;AAEA;;;;CAIC,GACDgB,QAAQE,aAAa,GAAG,SAASA;IAC/B,OAAOhB;AACT;AAEA;;;CAGC,GACDc,QAAQG,KAAK,GAAG,SAASA;IACvBnB,WAAW,CAAC;IACZC,mBAAmB,CAAC;IACpBC,aAAa,CAAC;IACdC,qBAAqB,CAAC;AACxB;AAEA;;;;;CAKC,GACDa,QAAQI,IAAI,GAAG,SAASA,KAAKC,OAAO,EAAEC,OAAO;IAC3C,IAAIT,SAASQ,SAASrB,aAAaa,SAASQ,SAASnB,aAAa;QAChE,MAAM,IAAIqB,MAAM,AAAC,YAAmB,OAARF,SAAQ;IACtC;IAEA,IAAI,CAACT,WAAWU,UAAU;QACxB,MAAM,IAAIC,MAAM,AAAC,YAAmB,OAARF,SAAQ;IACtC;IAEArB,QAAQ,CAACqB,QAAQ,GAAGC;AACtB;AAEA;;;;;CAKC,GACDN,QAAQQ,SAAS,GAAG,SAASA,UAAUH,OAAO,EAAEC,OAAO;IACrD,IAAIT,SAASQ,SAASnB,eAAeW,SAASQ,SAASrB,WAAW;QAChE,MAAM,IAAIuB,MAAM,AAAC,cAAqB,OAARF,SAAQ;IACxC;IAEAnB,UAAU,CAACmB,QAAQ,GAAGC;AACxB;AAEA;;;;;;CAMC,GACDN,QAAQS,GAAG,GAAG,SAASA,IAAIJ,OAAO;IAChC,qDAAqD;IACrD,IAAMK,OAAOC,MAAMpB,SAAS,CAACqB,KAAK,CAACnB,IAAI,CAACoB,WAAW;IAEnD,uBAAuB;IACvB,IAAIhB,SAASQ,SAASrB,WAAW;QAC/B,IAAIC,gBAAgB,CAACoB,QAAQ,EAAE;YAC7B,MAAM,IAAIE,MAAM,AAAC,0CAAiD,OAARF,SAAQ;QACpE;QAEApB,gBAAgB,CAACoB,QAAQ,GAAG;QAE5B,IAAMS,WAAW9B,QAAQ,CAACqB,QAAQ,CAACU,KAAK,CAAC,MAAML;QAE/CzB,gBAAgB,CAACoB,QAAQ,GAAG;QAE5B,OAAOS;IACT;IAEA,wBAAwB;IACxB,IAAIjB,SAASQ,SAASnB,aAAa;QACjC,IAAI,CAACW,SAASQ,SAASlB,qBAAqB;YAC1C,sEAAsE;YACtE,IAAIS,WAAWV,UAAU,CAACmB,QAAQ,GAAG;gBACnClB,kBAAkB,CAACkB,QAAQ,GAAGnB,UAAU,CAACmB,QAAQ,CAACU,KAAK,CAAC,MAAML;YAChE,OAAO;gBACLvB,kBAAkB,CAACkB,QAAQ,GAAGnB,UAAU,CAACmB,QAAQ;YACnD;QACF;QAEA,OAAOlB,kBAAkB,CAACkB,QAAQ;IACpC;IAEA,6BAA6B;IAC7B,MAAM,IAAIE,MAAM,AAAC,YAAmB,OAARF,SAAQ;AACtC;AAEA;;;;;;CAMC,GACDL,QAAQgB,IAAI,GAAG,SAASA,KAAKC,GAAG;IAC9B,IAAI,CAACrB,WAAWqB,MAAM;QACpB,MAAM,IAAIV,MAAM,AAAC,sDAAgE,OAAX,OAAOlB,oCAAP,SAAOA;IAC/E;IAEA,IAAI,CAAC4B,IAAIC,MAAM,EAAE;QACf,MAAM,IAAIX,MAAM,AAAC,kBAAsC,OAArBlB,IAAI8B,WAAW,CAACC,IAAI,EAAC;IACzD;IAEA,IAAMC,eAAeJ,IAAIC,MAAM;IAE/B,IAAIG,aAAaC,MAAM,EAAE;QACvB,IAAMC,WAAW,EAAE;QAEnBF,aAAaG,OAAO,CAAC,SAACC;YACpB,IAAI,CAACrC,SAASqC,eAAe,CAAC/B,SAAS+B,aAAa;gBAClD,MAAM,IAAIlB,MAAM;YAClB;YAEA,uBAAuB;YACvB,IAAInB,SAASqC,aAAa;gBACxBF,SAASG,IAAI,CAAC1B,QAAQS,GAAG,CAACgB;YAC5B;YAEA,mCAAmC;YACnC,IAAI/B,SAAS+B,aAAa;gBACxBA,WAAWf,IAAI,CAACiB,OAAO,CAACF,WAAW3B,GAAG;gBACtCyB,SAASG,IAAI,CAAC1B,QAAQS,GAAG,CAACM,KAAK,CAAC,MAAMU,WAAWf,IAAI;YACvD;QACF;QAEA,OAAO,IAAKkB,CAAAA,SAASrC,SAAS,CAACa,IAAI,CAACW,KAAK,CAACE,KAAK;YAAC;SAAK,CAACY,MAAM,CAACN,UAAS;IACxE;IACA,OAAO,IAAIN;AACb"}